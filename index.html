<!DOCTYPE html>
<html lang="de">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>üèê Better-HSP - Kursanmeldung</title>
  <style>
    * {
      box-sizing: border-box;
      margin: 0;
      padding: 0;
    }

    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
      background: #f5f5f5;
      min-height: 100vh;
      color: #333;
    }

    .container {
      max-width: 1200px;
      margin: 0 auto;
      padding: 20px;
    }

    header {
      text-align: center;
      padding: 30px 0;
    }

    header h1 {
      font-size: 2.5em;
      color: #91C736;
      margin-bottom: 10px;
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 15px;
    }

    header h1 img {
      height: 50px;
      width: auto;
    }

    header p {
      color: #666;
      font-size: 1.1em;
    }

    .status-bar {
      background: #fff;
      border-radius: 12px;
      padding: 15px 25px;
      margin-bottom: 30px;
      display: flex;
      justify-content: space-between;
      align-items: center;
      flex-wrap: wrap;
      gap: 15px;
      box-shadow: 0 2px 8px rgba(0,0,0,0.1);
    }

    .status-item {
      display: flex;
      align-items: center;
      gap: 10px;
    }

    .status-dot {
      width: 12px;
      height: 12px;
      border-radius: 50%;
      background: #ff4444;
    }

    .status-dot.connected {
      background: #91C736;
      box-shadow: 0 0 10px #91C736;
    }

    .tabs {
      display: flex;
      gap: 10px;
      margin-bottom: 20px;
    }

    .tab {
      padding: 12px 24px;
      background: #fff;
      border: none;
      border-radius: 8px;
      color: #666;
      cursor: pointer;
      font-size: 1em;
      transition: all 0.3s;
      box-shadow: 0 2px 4px rgba(0,0,0,0.08);
    }

    .tab:hover {
      background: #f9f9f9;
      box-shadow: 0 2px 6px rgba(0,0,0,0.12);
    }

    .tab.active {
      background: #91C736;
      color: #fff;
      font-weight: bold;
      box-shadow: 0 2px 8px rgba(145,199,54,0.3);
    }

    .panel {
      display: none;
      background: #fff;
      border-radius: 16px;
      padding: 24px;
      box-shadow: 0 2px 8px rgba(0,0,0,0.1);
    }

    .panel.active {
      display: block;
    }

    h2 {
      color: #91C736;
      margin-bottom: 20px;
      font-size: 1.5em;
    }

    label {
      display: block;
      margin-bottom: 8px;
      color: #666;
      font-size: 0.95em;
    }

    input, select, textarea {
      width: 100%;
      padding: 12px 15px;
      background: #f9f9f9;
      border: 1px solid #ddd;
      border-radius: 8px;
      color: #333;
      font-size: 1em;
    }

    option {
      color: #333;
    }

    input:focus, select:focus, textarea:focus {
      outline: none;
      border-color: #91C736;
      background: #fff;
    }

    textarea {
      min-height: 200px;
      font-family: monospace;
      font-size: 0.9em;
    }

    .btn {
      padding: 12px 24px;
      border: none;
      border-radius: 8px;
      font-size: 1em;
      cursor: pointer;
      transition: all 0.3s;
      display: inline-flex;
      align-items: center;
      gap: 8px;
    }

    .btn-primary {
      background: #91C736;
      color: #fff;
      font-weight: bold;
      box-shadow: 0 2px 4px rgba(145,199,54,0.2);
    }

    .btn-primary:hover {
      background: #7fb32a;
      transform: translateY(-2px);
      box-shadow: 0 4px 8px rgba(145,199,54,0.3);
    }

    .btn-primary:disabled,
    .btn-secondary:disabled {
      opacity: 0.5;
      background-color: #ccc;
      color: #666;
      cursor: not-allowed;
      transform: none !important;
      box-shadow: none;
    }

    .btn-primary:disabled:hover,
    .btn-secondary:disabled:hover {
      background: #ccc;
      transform: none;
    }

    .btn-danger {
      background: #ff4444;
      color: white;
    }

    .btn-danger:hover {
      background: #ff2222;
    }

    .btn-secondary {
      background: #fff;
      color: #91C736;
      border: 2px solid #91C736;
      box-shadow: 0 2px 4px rgba(0,0,0,0.1);
    }

    .btn-secondary:hover {
      background: #f0f8e8;
      transform: translateY(-1px);
    }

    .filter-row {
      display: flex;
      flex-wrap: wrap;
      width: 100%;
      justify-content: center;
      gap: 8px;
    }

    .header-filter {
      display: flex;
      flex-direction: column;
      justify-content: space-between;
      align-items: center;
      flex-wrap: wrap;
      gap: 8px;
    }

    .header-filter h2 {
      margin: 0;
    }

    .courses-list {
      margin-top: 20px;
    }

    .course-card {
      background: #fff;
      border-radius: 12px;
      padding: 20px;
      margin-bottom: 15px;
      display: grid;
      grid-template-columns: 1fr auto;
      gap: 15px;
      align-items: center;
      transition: all 0.3s;
      box-shadow: 0 2px 6px rgba(0,0,0,0.08);
    }

    .course-card:hover {
      box-shadow: 0 4px 12px rgba(0,0,0,0.12);
      transform: translateY(-2px);
    }

    .course-card.full {
      border: 1px dashed #ff4444;
      opacity: 0.7;
    }

    .course-card.booked {
      border: 2px solid #91C736;
      background: #f0f8e8;
    }

    .course-card.waiting {
      border: 2px solid #ffaa00;
      background: #fff9e6;
    }

    .course-info h3 {
      color: #333;
      margin-bottom: 8px;
      font-size: 1.1em;
    }

    .course-meta {
      display: flex;
      flex-wrap: wrap;
      gap: 15px;
      color: #666;
      font-size: 0.9em;
    }

    .course-meta span {
      display: flex;
      align-items: flex-end;
      gap: 5px;
    }

    .availability {
      padding: 8px 16px;
      border-radius: 20px;
      font-weight: bold;
      font-size: 0.9em;
    }

    .availability.available {
      background: rgba(145, 199, 54, 0.15);
      color: #91C736;
    }

    .availability.full {
      background: rgba(255, 68, 68, 0.15);
      color: #ff4444;
    }

    .course-actions {
      display: flex;
      flex-direction: column;
      gap: 8px;
    }

    .course-actions .btn {
      justify-content: center;
      padding: 8px 16px;
      font-size: 0.9em;
    }

    .btn-link {
      background: none;
      border: none;
      color: #91C736;
      cursor: pointer;
      font-weight: 600;
      text-decoration: none;
      transition: color 0.2s;
    }

    .btn-link:hover {
      color: #7fb32a;
      text-decoration: underline;
    }

    .instructions {
      background: #f0f8e8;
      border-radius: 12px;
      padding: 20px;
      margin-bottom: 20px;
      border-left: 4px solid #91C736;
    }

    .instructions h3 {
      color: #91C736;
      margin-bottom: 15px;
    }

    .instructions ol {
      padding-left: 20px;
    }

    .instructions li {
      margin-bottom: 10px;
      line-height: 1.6;
    }

    .instructions code {
      background: rgba(145,199,54,0.2);
      padding: 2px 8px;
      border-radius: 4px;
      font-family: monospace;
      color: #5a8c1f;
    }

    .log-container {
      background: #f9f9f9;
      border-radius: 12px;
      padding: 20px;
      margin-top: 20px;
      max-height: 400px;
      overflow-y: auto;
      border: 1px solid #ddd;
    }

    .log-entry {
      font-family: monospace;
      font-size: 0.9em;
      padding: 8px 0;
      border-bottom: 1px solid #e0e0e0;
      display: flex;
      gap: 10px;
      color: #333;
    }

    .log-entry .time {
      color: #999;
      min-width: 80px;
    }

    .log-entry.success {
      color: #91C736;
    }

    .log-entry.error {
      color: #ff4444;
    }

    .log-entry.info {
      color: #2196F3;
    }

    .log-entry.warning {
      color: #ffaa00;
    }

    .active-jobs {
      margin-top: 20px;
    }

    .job-card {
      background: #fff9e6;
      border-radius: 12px;
      padding: 20px;
      margin-bottom: 15px;
      border-left: 4px solid #ffaa00;
      box-shadow: 0 2px 6px rgba(0,0,0,0.08);
    }

    .job-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 15px;
    }

    .job-stats {
      display: flex;
      gap: 20px;
      color: #666;
      font-size: 0.9em;
    }

    .spinner {
      display: inline-block;
      width: 20px;
      height: 20px;
      border: 3px solid #e0e0e0;
      border-radius: 50%;
      border-top-color: #91C736;
      animation: spin 1s linear infinite;
    }

    @keyframes spin {
      to { transform: rotate(360deg); }
    }

    @keyframes pulse {
      0%, 100% { transform: scale(1); }
      50% { transform: scale(1.1); }
    }

    @keyframes flash {
      0%, 100% { opacity: 1; }
      50% { opacity: 0.7; background: rgba(145, 199, 54, 0.1); }
    }

    .modal {
      display: none;
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: rgba(0,0,0,0.6);
      z-index: 1000;
      align-items: center;
      justify-content: center;
    }

    .modal.active {
      display: flex;
    }

    .modal-content {
      background: #fff;
      border-radius: 16px;
      padding: 30px;
      max-width: 500px;
      width: 90%;
      box-shadow: 0 8px 32px rgba(0,0,0,0.2);
    }

    .modal-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 20px;
    }

    .modal-header h3 {
      color: #333;
    }

    .modal-close {
      background: none;
      border: none;
      color: #999;
      font-size: 1.5em;
      cursor: pointer;
    }

    .modal-close:hover {
      color: #333;
    }

    .alert {
      padding: 15px 20px;
      border-radius: 8px;
      margin-bottom: 20px;
    }

    .alert-success {
      background: rgba(145, 199, 54, 0.15);
      border: 1px solid #91C736;
      color: #5a8c1f;
    }

    .alert-error {
      background: rgba(255, 68, 68, 0.15);
      border: 1px solid #ff4444;
      color: #cc0000;
    }

    .hidden {
      display: none !important;
    }

    .scheduled-jobs {
      margin-top: 30px;
      padding-top: 20px;
      border-top: 1px solid #e0e0e0;
    }

    .scheduled-job-card {
      background: #f9f9f9;
      border-radius: 12px;
      padding: 15px 20px;
      margin-bottom: 15px;
      border-left: 4px solid #91C736;
      box-shadow: 0 2px 6px rgba(0,0,0,0.08);
    }

    .scheduled-job-card.running {
      border-left-color: #ffaa00;
      background: #fff9e6;
    }

    .scheduled-job-card.completed {
      border-left-color: #91C736;
      opacity: 0.7;
    }

    .scheduled-job-card.failed {
      border-left-color: #ff4444;
      background: #fff5f5;
    }

    .schedule-info {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
      gap: 10px;
      margin-top: 10px;
      font-size: 0.9em;
      color: #666;
    }

    .schedule-info-item {
      display: flex;
      flex-direction: column;
      gap: 2px;
    }

    .schedule-info-label {
      font-size: 0.8em;
      color: #999;
    }

    .schedule-time-highlight {
      color: #91C736;
      font-weight: bold;
    }

   @media (max-width: 768px) {
      .container {
        padding: 15px;
      }

      header h1 {
        font-size: 1.8em;
      }

      header p {
        font-size: 0.9em;
      }

      .header-filter {
        gap: 15px;
      }

      .header-filter h2 {
        font-size: 1.3em;
      }

      .tabs {
        justify-content: center;
      }

      .filter-row {
        flex-direction: column;
        gap: 12px;
        width: 100%;
      }

      .filter-row .form-group {
        width: 100%;
      }

      .filter-row input,
      .filter-row select {
        padding: 10px 12px;
        font-size: 16px; /* Prevents zoom on iOS */
      }

      .filter-row label {
        font-size: 0.9em;
        margin-bottom: 6px;
      }

      .btn {
        width: 100%;
        justify-content: center;
        padding: 12px 20px;
        font-size: 1em;
      }

      .course-card {
        grid-template-columns: 1fr;
        padding: 15px;
        gap: 12px;
      }
      
      .course-actions {
        flex-direction: row;
        width: 100%;
      }

      .course-actions .btn {
        flex: 1;
      }

      .course-meta {
        font-size: 0.85em;
        gap: 10px;
      }

      .tabs {
        gap: 5px;
      }

      .tab {
        padding: 10px 12px;
        font-size: 0.9em;
      }

      .modal-content {
        width: 90%;
        max-width: 90%;
        padding: 20px;
      }

      .status-bar {
        flex-direction: column;
        gap: 8px;
        padding: 12px;
      }

      .status-item {
        font-size: 0.9em;
      }

      input, select, textarea {
        font-size: 16px; /* Prevents zoom on iOS */
      }
    }
  </style>
</head>
<body>
  <div class="container">
    <header>
      <h1><img src="resources/logo.png" alt="HSP Logo"> HSP-Bot</h1>
      <p>Automatische Kursanmeldung f√ºr den Hochschulsport</p>
    </header>

    <div class="status-bar">
      <div class="status-item">
        <div class="status-dot" id="wsStatus"></div>
        <span id="wsStatusText">Verbinde...</span>
      </div>
      <div class="status-item">
        <span>üë§</span>
        <span id="userStatus">Nicht angemeldet</span>
      </div>
      <div class="status-item">
        <span>üîë</span>
        <span id="tokenStatus">-</span>
      </div>
    </div>

    <div class="tabs">
      <button class="tab active" data-tab="courses"> Kurse suchen</button>
      <button class="tab" data-tab="register"> Anmeldung</button>
      <button class="tab" data-tab="auth"> Auth-Daten</button>
    </div>

    <!-- Kurse suchen Panel -->
    <div class="panel active" id="panel-courses">
      <h2>Kurse suchen</h2>
      <div class="header-filter">
      <div class="filter-row">
        <div class="form-group">
          <label>Sportart</label>
          <input list="sportsList" id="filterSport" placeholder="Tippen zum Suchen..." autocomplete="off">
          <datalist id="sportsList"></datalist>
          <input type="hidden" id="filterSportId">
        </div>
        <div class="form-group">
          <label>Zeitraum (Tage)</label>
          <input type="number" id="filterDays" value="8" min="1" max="30">
        </div>
        <div class="form-group">
          <label>Level</label>
          <select id="filterLevel">
            <option value="">Alle</option>
            <option value="1">Level 1</option>
            <option value="2">Level 2</option>
            <option value="3">Level 3</option>
          </select>
        </div>
        <div class="form-group">
          <label>Min. freie Pl√§tze</label>
          <input type="number" id="filterAvailable" value="0" min="0">
        </div>
        <div class="form-group" style="display: flex; align-items: flex-end;">
          <button class="btn btn-primary" id="searchBtn">üîç Suchen</button>
          </div>
        </div>
      </div>

      <div id="coursesLoading" class="hidden">
        <span class="spinner"></span> Lade Kurse...
      </div>

      <div class="courses-list" id="coursesList"></div>
    </div>

    <!-- Anmeldung Panel -->
    <div class="panel" id="panel-register">
      <h2>Kurs-Anmeldung</h2>
      
      <div class="form-group">
        <label>Booking ID</label>
        <input type="number" id="bookingId" placeholder="z.B. 36432">
      </div>

      <div class="filter-row">
        <div class="form-group">
          <label>Modus</label>
          <select id="registerMode">
            <option value="single">Einmalige Anmeldung</option>
            <option value="polling">Wiederholend (Polling)</option>
          </select>
        </div>
        <div class="form-group" id="intervalGroup">
          <label>Intervall (Millisekunden)</label>
          <input type="number" id="intervalSeconds" value="1000" min="100" step="100">
        </div>
        <div class="form-group" id="maxAttemptsGroup">
          <label>Max. Versuche (leer = unbegrenzt)</label>
          <input type="number" id="maxAttempts" placeholder="z.B. 20" min="1">
        </div>
      </div>

      <button class="btn btn-primary" id="registerBtn">Anmeldung starten</button>

      <div class="active-jobs" id="activeJobs"></div>

      <div class="scheduled-jobs" id="scheduledJobsSection">
        <h3 style="margin-bottom: 15px;">üìÖ Geplante Buchungen</h3>
        <div id="scheduledJobsList"></div>
      </div>

      <div class="log-container" id="logContainer">
        <div class="log-entry info">
          <span class="time">--:--:--</span>
          <span>Bereit f√ºr Anmeldungen...</span>
        </div>
      </div>
    </div>

    <!-- Auth-Daten Panel -->
    <div class="panel" id="panel-auth">
      <h2>Authentifizierungsdaten importieren</h2>

      <div class="instructions">
        <h3>Anleitung zum Abrufen der Auth-Daten</h3>
        <ol>
          <li>√ñffne die <a href="https://buchung.hssp-muenster.de/" target="_blank" style="color: #91C736;">HSP-Website</a> und melde dich an</li>
          <li>Dr√ºcke <code>F12</code> um die Entwickler-Tools zu √∂ffnen</li>
          <li>Wechsle zum Tab <code>Console</code></li>
          <li>Gib folgenden Befehl ein und dr√ºcke Enter:
            <br><code>localStorage.getItem("delcom_auth")</code>
          </li>
          <li>Kopiere die komplette Ausgabe (mit Anf√ºhrungszeichen)</li>
          <li>F√ºge sie unten in das Textfeld ein</li>
        </ol>
      </div>

      <div class="form-group">
        <label>Auth-Daten (JSON)</label>
        <textarea id="authDataInput" placeholder='Hier den kopierten Text einf√ºgen...'></textarea>
      </div>

      <div class="form-group">
        <label style="display: flex; align-items: center; gap: 10px; cursor: pointer;">
          <input type="checkbox" id="autoFixJson" checked style="width: auto;">
          <span>Automatische Format-Korrektur (bei Problemen deaktivieren)</span>
        </label>
      </div>

      <button class="btn btn-primary" id="importAuthBtn">Importieren</button>

      <div id="authResult" class="hidden"></div>
    </div>
  </div>

  <!-- Polling Modal -->
  <div class="modal" id="pollingModal">
    <div class="modal-content">
      <div class="modal-header">
        <h3>Polling-Anmeldung</h3>
        <button class="modal-close" onclick="closePollingModal()">√ó</button>
      </div>
      <p>W√§hle die Einstellungen f√ºr die wiederholte Anmeldung:</p>
      <div class="form-group">
        <label>Intervall (Millisekunden)</label>
        <input type="number" id="modalInterval" value="1000" min="100" step="100">
      </div>
      <div class="form-group">
        <label>Max. Versuche (leer = unbegrenzt)</label>
        <input type="number" id="modalMaxAttempts" placeholder="z.B. 20">
      </div>
      <input type="hidden" id="modalBookingId">
      <button class="btn btn-primary" onclick="startPollingFromModal()">Starten</button>
    </div>
  </div>

  <!-- Schedule Modal -->
  <div class="modal" id="scheduleModal">
    <div class="modal-content">
      <div class="modal-header">
        <h3>Buchung planen</h3>
        <button class="modal-close" onclick="closeScheduleModal()">√ó</button>
      </div>
      <p id="scheduleModalCourse" style="margin-bottom: 15px; color: #91C736; font-weight: bold;"></p>
      <div class="schedule-info" style="margin-bottom: 20px;">
        <div class="schedule-info-item">
          <span class="schedule-info-label">Kurs-Startzeit</span>
          <span id="scheduleCourseTime"></span>
        </div>
        <div class="schedule-info-item">
          <span class="schedule-info-label">Buchung verf√ºgbar ab</span>
          <span id="scheduleBookingAvailable" class="schedule-time-highlight"></span>
        </div>
        <div class="schedule-info-item">
          <span class="schedule-info-label">Polling startet</span>
          <span id="schedulePollingStart"></span>
        </div>
        <div class="schedule-info-item">
          <span class="schedule-info-label">Polling endet</span>
          <span id="schedulePollingStop"></span>
        </div>
      </div>
      <p style="font-size: 0.9em; color: #666; margin-bottom: 20px;">
        Der Bot startet automatisch im zuf√§lligen 10-Sekunden-Fenster vor der Buchungsverf√ºgbarkeit und versucht bis 20 Sekunden danach, dich anzumelden.
      </p>
      <div id="scheduleModalError" class="alert alert-error hidden" style="margin-bottom: 15px;"></div>
      <input type="hidden" id="scheduleBookingId">
      <input type="hidden" id="scheduleCourseStartTime">
      <input type="hidden" id="scheduleCourseDescription">
      <button class="btn btn-primary" onclick="confirmSchedule()" id="scheduleConfirmBtn">Buchung planen</button>
    </div>
  </div>

   <!-- Map Service Selection Modal -->
  <div class="modal" id="mapModal">
    <div class="modal-content">
      <div class="modal-header">
        <h3 id="mapModalTitle">Kartendienst w√§hlen</h3>
        <button class="modal-close" onclick="closeMapModal()">√ó</button>
      </div>
      <p id="mapModalSubtitle">W√§hle einen Kartendienst:</p>
      <div id="mapServiceButtons" style="display: flex; flex-direction: column; gap: 10px; margin-top: 20px;">
        <!-- Buttons will be dynamically added here -->
      </div>
    </div>
  </div>

  <script>
    // WebSocket Verbindung
    let ws = null;
    let activeJobs = new Map();
    let locationsData = {};
    let scheduledJobsMap = new Map(); // Map of bookingId -> scheduled job

    // Load locations data
    async function loadLocations() {
      try {
        const res = await fetch('/api/locations');
        if (res.ok) {
          locationsData = await res.json();
          console.log(`Loaded ${Object.keys(locationsData).length} locations`);
        }
      } catch (error) {
        console.error('Failed to load locations:', error);
      }
    }

    // Open location in map service
    function openLocation(locationId, locationName) {
      // Look up location by ID
      const location = locationsData[locationId];
      
      if (!location || !location.latitude || !location.longitude) {
        console.error('Location not found:', locationId, locationName);
        alert('Standort-Daten nicht verf√ºgbar');
        return;
      }

      const lat = location.latitude;
      const lng = location.longitude;
      const name = location.description || locationName;
      
      // Detect device type
      const isMobile = /iPhone|iPad|iPod|Android/i.test(navigator.userAgent);
      const isIOS = /iPhone|iPad|iPod/i.test(navigator.userAgent);
      
      // Build map service options
      let services = [];
      
      if (isMobile && isIOS) {
        services = [
          { name: 'Apple Maps', url: `maps://maps.apple.com/?q=${encodeURIComponent(name)}&ll=${lat},${lng}` },
          { name: 'Google Maps', url: `https://maps.google.com/?q=${lat},${lng}` }
        ];
      } else if (isMobile) {
        services = [
          { name: 'Google Maps', url: `geo:${lat},${lng}?q=${lat},${lng}(${encodeURIComponent(name)})` }
        ];
      } else {
        services = [
          { name: 'Google Maps', url: `https://www.google.com/maps?q=${lat},${lng}` },
          { name: 'OpenStreetMap', url: `https://www.openstreetmap.org/?mlat=${lat}&mlon=${lng}&zoom=19` }
        ];
      }
      
      // Show modal with service options
      showMapModal(name, services);
    }

    function showMapModal(locationName, services) {
      const modal = document.getElementById('mapModal');
      const title = document.getElementById('mapModalTitle');
      const subtitle = document.getElementById('mapModalSubtitle');
      const buttonsContainer = document.getElementById('mapServiceButtons');
      
      title.textContent = 'Kartendienst w√§hlen';
      subtitle.textContent = `Standort: ${locationName}`;
      
      // Clear previous buttons
      buttonsContainer.innerHTML = '';
      
      // Add service buttons
      services.forEach(service => {
        const button = document.createElement('button');
        button.className = 'btn btn-primary';
        button.textContent = service.name;
        button.onclick = () => {
          window.open(service.url, '_blank');
          closeMapModal();
        };
        buttonsContainer.appendChild(button);
      });
      
      // Add cancel button
      const cancelBtn = document.createElement('button');
      cancelBtn.className = 'btn btn-secondary';
      cancelBtn.textContent = 'Abbrechen';
      cancelBtn.onclick = closeMapModal;
      buttonsContainer.appendChild(cancelBtn);
      
      modal.style.display = 'flex';
    }

    function closeMapModal() {
      document.getElementById('mapModal').style.display = 'none';
    }

    function connectWebSocket() {
      const protocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
      const wsUrl = `${protocol}//${window.location.host}/ws`;
      ws = new WebSocket(wsUrl);

      ws.onopen = () => {
        document.getElementById('wsStatus').classList.add('connected');
        document.getElementById('wsStatusText').textContent = 'Verbunden';
      };

      ws.onclose = () => {
        document.getElementById('wsStatus').classList.remove('connected');
        document.getElementById('wsStatusText').textContent = 'Getrennt';
        setTimeout(connectWebSocket, 3000);
      };

      ws.onmessage = (event) => {
        const data = JSON.parse(event.data);
        handleWebSocketMessage(data);
      };
    }

    function handleWebSocketMessage(data) {
      const logContainer = document.getElementById('logContainer');
      const time = new Date().toLocaleTimeString('de-DE');

       switch (data.type) {
        case 'jobStarted':
          addLog('info', `Job gestartet: Booking ${data.bookingId}, Intervall: ${data.intervalSeconds}s`);
          isPolling = true;
          activeJobs.set(data.jobId, {
            bookingId: data.bookingId,
            attempts: 0,
            intervalSeconds: data.intervalSeconds,
            maxAttempts: data.maxAttempts
          });
          renderActiveJobs();
          break;

        case 'scheduleTriggered':
          addLog('info', `üìÖ Geplante Buchung gestartet: Booking ${data.bookingId}`);
          loadScheduledJobs();
          break;

        case 'scheduleAttempt':
          const schedType = data.success ? 'success' : (data.rateLimited ? 'warning' : 'info');
          addLog(schedType, `üìÖ Versuch ${data.attempt}: ${data.message}`);
          break;

        case 'scheduleCompleted':
          addLog(data.success ? 'success' : 'warning', 
            `üìÖ Geplante Buchung beendet: ${data.message} (${data.totalAttempts} Versuche)`);
          loadScheduledJobs();
          // Refresh course list if successful
          if (data.success) {
            setTimeout(() => searchCourses(true), 1000);
          }
          break;

        case 'scheduleError':
          addLog('error', `üìÖ Fehler bei geplanter Buchung: ${data.message}`);
          loadScheduledJobs();
          break;

        case 'attempt':
          const type = data.success ? 'success' : (data.rateLimited ? 'warning' : 'error');
          addLog(type, `Versuch ${data.attempt}: ${data.message}`);
          if (activeJobs.has(data.jobId)) {
            activeJobs.get(data.jobId).attempts = data.attempt;
            renderActiveJobs();
          }
          break;

        case 'success':
          const successMsg = data.isWaitlist ? `‚ö†Ô∏è Warteliste: ${data.message}` : `‚úÖ ${data.message}`;
          addLog(data.isWaitlist ? 'warning' : 'success', successMsg);
          if (data.fullResponse) {
            addLog('info', `Server: ${JSON.stringify(data.fullResponse)}`);
          }
          break;

        case 'jobCompleted':
          addLog(data.success ? 'success' : 'info', 
            `Job beendet nach ${data.totalAttempts} Versuchen: ${data.success ? 'Erfolgreich!' : data.message}`);
          activeJobs.delete(data.jobId);
          isPolling = activeJobs.size > 0;
          renderActiveJobs();
          // Refresh course list if successful booking (silent mode)
          if (data.success) {
            setTimeout(() => searchCourses(true), 1000);
          }
          break;

        case 'jobStopped':
          addLog('info', `Job gestoppt nach ${data.totalAttempts} Versuchen`);
          activeJobs.delete(data.jobId);
          isPolling = activeJobs.size > 0;
          renderActiveJobs();
          break;

        case 'error':
          addLog('error', data.message);
          break;
      }
    }

    function addLog(type, message) {
      const logContainer = document.getElementById('logContainer');
      const time = new Date().toLocaleTimeString('de-DE');
      const entry = document.createElement('div');
      entry.className = `log-entry ${type}`;
      entry.innerHTML = `<span class="time">${time}</span><span>${message}</span>`;
      logContainer.insertBefore(entry, logContainer.firstChild);
    }

    function renderActiveJobs() {
      const container = document.getElementById('activeJobs');
      if (activeJobs.size === 0) {
        container.innerHTML = '';
        return;
      }

      let html = '<h3 style="margin-bottom: 15px;">üîÑ Aktive Jobs</h3>';
      activeJobs.forEach((job, jobId) => {
        html += `
          <div class="job-card">
            <div class="job-header">
              <div>
                <strong>Booking ${job.bookingId}</strong>
                <span class="spinner" style="margin-left: 10px;"></span>
              </div>
              <button class="btn btn-danger" onclick="stopJob('${jobId}')">‚èπ Stoppen</button>
            </div>
            <div class="job-stats">
              <span>Versuche: ${job.attempts}</span>
              <span>Intervall: ${job.intervalSeconds}ms</span>
              <span>Max: ${job.maxAttempts || 'unbegrenzt'}</span>
            </div>
          </div>
        `;
      });
      container.innerHTML = html;
    }

    function stopJob(jobId) {
      if (ws && ws.readyState === WebSocket.OPEN) {
        ws.send(JSON.stringify({ type: 'stopPolling', jobId }));
      }
    }

    // Tab Navigation
    document.querySelectorAll('.tab').forEach(tab => {
      tab.addEventListener('click', () => {
        document.querySelectorAll('.tab').forEach(t => t.classList.remove('active'));
        document.querySelectorAll('.panel').forEach(p => p.classList.remove('active'));
        tab.classList.add('active');
        document.getElementById(`panel-${tab.dataset.tab}`).classList.add('active');
      });
    });

    // Status laden
    async function loadStatus() {
      try {
        const res = await fetch('/api/status');
        const data = await res.json();

        if (data.authenticated && data.member) {
          document.getElementById('userStatus').textContent = 
            data.member.memberName || data.member.memberEmail || `ID: ${data.member.memberId}`;
        }

        if (data.tokenInfo) {
          document.getElementById('tokenStatus').textContent = 
            data.tokenInfo.isValid ? `G√ºltig (${data.tokenInfo.remainingText})` : 'Abgelaufen';
        }
      } catch (error) {
        console.error('Status laden fehlgeschlagen:', error);
      }
    }

    // Sportarten laden
    let sportsMap = new Map();
    async function loadSports() {
      try {
        const res = await fetch('/api/sports');
        const sports = await res.json();
        
        const datalist = document.getElementById('sportsList');
        const input = document.getElementById('filterSport');
        
        sports.forEach(s => {
          const option = document.createElement('option');
          option.value = s.name;
          datalist.appendChild(option);
          sportsMap.set(s.name, s.id);
          
          // Default Volleyball
          if (s.id === 285) {
             input.value = s.name;
             document.getElementById('filterSportId').value = s.id;
          }
        });
        
        // Input Handler f√ºr ID Mapping
        input.addEventListener('input', (e) => {
            const val = e.target.value;
            const id = sportsMap.get(val);
            if (id) {
                document.getElementById('filterSportId').value = id;
            } else {
                document.getElementById('filterSportId').value = '';
            }
        });
        
        // Initial search if we have a default
        if (input.value) document.getElementById('searchBtn').click();

      } catch (e) {
        console.error('Fehler beim Laden der Sportarten:', e);
      }
    }

    // Enter-Taste f√ºr Suche
    ['filterSport', 'filterDays', 'filterLevel', 'filterAvailable'].forEach(id => {
      const element = document.getElementById(id);
      if (element) {
        element.addEventListener('keydown', (e) => {
          if (e.key === 'Enter') {
            e.preventDefault();
            document.getElementById('searchBtn').click();
          }
        });
      }
    });

    // Kurse suchen
    let autoRefreshInterval = null;
    let isPolling = false;
    let isRefreshing = false;

    async function searchCourses(silent = false) {
      const days = document.getElementById('filterDays').value;
      const level = document.getElementById('filterLevel').value;
      const minAvailable = document.getElementById('filterAvailable').value;
      const sportId = document.getElementById('filterSportId').value;
      
      // Fallback: Wenn User tippt aber nicht exakt ausw√§hlt, versuchen wir zu matchen (case insensitive)
      if (!sportId) {
         const val = document.getElementById('filterSport').value.toLowerCase();
         for (let [name, id] of sportsMap.entries()) {
             if (name.toLowerCase() === val) {
                 document.getElementById('filterSportId').value = id;
                 break;
             }
         }
      }
      
      // Wenn immer noch kein ID, warnen (oder Volleyball nehmen?)
      const finalSportId = document.getElementById('filterSportId').value || 285; // Fallback Volleyball

      // Only show loading and clear list on initial search, not on refresh
      if (!silent) {
        document.getElementById('coursesLoading').classList.remove('hidden');
        document.getElementById('coursesList').innerHTML = '';
      } else {
        isRefreshing = true;
      }

      try {
        const params = new URLSearchParams({ days });
        if (level) params.append('level', level);
        if (minAvailable > 0) params.append('minAvailable', minAvailable);
        if (finalSportId) params.append('sportId', finalSportId);

        const res = await fetch(`/api/courses?${params}`);
        const data = await res.json();

        renderCourses(data.courses, silent);
      } catch (error) {
        if (!silent) {
          document.getElementById('coursesList').innerHTML = 
            `<div class="alert alert-error">Fehler: ${error.message}</div>`;
        }
      } finally {
        document.getElementById('coursesLoading').classList.add('hidden');
        isRefreshing = false;
      }
    }

    document.getElementById('searchBtn').addEventListener('click', async () => {
      await searchCourses(false);
      startAutoRefresh();
    });

    // Auto-refresh every 30 seconds (at :00 and :30 of each minute)
    function startAutoRefresh() {
      // Clear existing interval
      if (autoRefreshInterval) {
        clearInterval(autoRefreshInterval);
      }

      // Calculate time until next 30-second mark
      const now = new Date();
      const seconds = now.getSeconds();
      const msUntilNext30 = ((30 - (seconds % 30)) % 30) * 1000;

      // Wait until next 30-second mark, then refresh every 30 seconds
      setTimeout(() => {
        // Do initial refresh
        if (!isPolling) {
          searchCourses(true);
        }

        // Set up interval for every 30 seconds
        autoRefreshInterval = setInterval(() => {
          if (!isPolling) {
            searchCourses(true);
          }
        }, 30000);
      }, msUntilNext30 || 30000);
    }

    function renderCourses(courses, silent = false) {
      const container = document.getElementById('coursesList');
      
      if (courses.length === 0 && !silent) {
        container.innerHTML = '<p style="text-align: center; color: #888; padding: 40px;">Keine Kurse gefunden</p>';
        return;
      }

      if (courses.length === 0 && silent) {
        return; // Don't clear existing courses on silent refresh if no results
      }

      const days = ['Sonntag', 'Montag', 'Dienstag', 'Mittwoch', 'Donnerstag', 'Freitag', 'Samstag'];
      
      // If silent refresh, update existing cards instead of replacing all HTML
      if (silent && container.children.length > 0) {
        courses.forEach(course => {
          const existingCard = container.querySelector(`[data-course-id="${course.id}"]`);
          if (existingCard) {
            updateCourseCard(existingCard, course);
          } else {
            // New course appeared, add it
            const newCard = createCourseCard(course, days);
            container.appendChild(newCard);
          }
        });
        return;
      }

      // Initial render or explicit refresh
      let html = '';
      courses.forEach(course => {
        const date = new Date(course.startDate);
        const dayName = days[date.getUTCDay()];
        const time = date.toLocaleTimeString('de-DE', { hour: '2-digit', minute: '2-digit' });
        const dateStr = date.toLocaleDateString('de-DE');
        const isFull = course.available <= 0;
        const supervisors = course.supervisors && course.supervisors.length > 0 
          ? `<span>üë§ ${course.supervisors.map(s => `${s.firstName} ${s.lastName}`).join(', ')}</span>` 
          : '';
        
        // Check user participation status
        const isBooked = course.userParticipation?.participationStatus === 1;
        const isWaiting = course.userParticipation?.participationStatus === 3;
        const isScheduled = scheduledJobsMap.has(course.id);
        const cardClass = isBooked ? 'booked' : (isWaiting ? 'waiting' : (isFull ? 'full' : ''));
        let statusBadge = '';
        if (isBooked) {
          statusBadge = '<span style="color: #91C736; font-weight: bold;">Angemeldet</span>';
        } else if (isWaiting) {
          statusBadge = '<span style="color: #ffaa00; font-weight: bold;">‚ö†Ô∏è Warteliste</span>';
        } else if (isScheduled) {
          const scheduledJob = scheduledJobsMap.get(course.id);
          const statusIcon = scheduledJob.status === 'running' ? 'üîÑ' : 'üìÖ';
          statusBadge = `<span style="color: #91C736; font-weight: bold;">${statusIcon} Geplant</span>`;
        }

        const locationButton = course.locationId 
          ? `<button class="btn-link" onclick="openLocation(${course.locationId}, '${course.location.replace(/'/g, "\\'")}')">üó∫Ô∏è</button>`
          : '';

        html += `
          <div class="course-card ${cardClass}" data-course-id="${course.id}">
            <div class="course-info">
              <h3>${course.description} ${statusBadge}</h3>
              <div class="course-meta">
                ${course.level ? `<strong>${course.level}</strong>` : ''}
                <span>üìÖ ${dayName}, ${dateStr}</span>
                <span>üïê ${time} Uhr</span>
                <span>üìç ${course.location} ${locationButton}</span>
                <span>üé´ ID: ${course.id}</span>
                ${supervisors}
              </div>
            </div>
            <div style="display: flex; align-items: center; gap: 15px;">
              <span class="availability ${isFull ? 'full' : 'available'}" data-available="${course.available}">
                ${isFull ? 'Voll' : `${course.available} frei`}
              </span>
              <div class="course-actions">
                <button class="btn btn-primary" onclick="quickRegister(${course.id})" ${isBooked || isWaiting ? 'disabled' : ''}>
                  ${isBooked ? 'Angemeldet' : (isWaiting ? 'Warteliste' : (isFull ? 'Warteliste' : 'Anmelden'))}
                </button>
                <button class="btn btn-secondary" onclick="openPollingModal(${course.id})" ${isBooked || isWaiting ? 'disabled' : ''}>
                  Polling
                </button>
                <button class="btn btn-secondary" onclick="openScheduleModal(${course.id}, '${course.startDate}', '${course.description.replace(/'/g, "\\'")}')" ${isBooked || isWaiting || isScheduled ? 'disabled' : ''}>
                  ${isScheduled ? 'Geplant' : 'Planen'}
                </button>
              </div>
            </div>
          </div>
        `;
      });

      container.innerHTML = html;
    }

    // Update existing course card without full re-render
    function updateCourseCard(card, course) {
      const availabilityEl = card.querySelector('.availability');
      const oldAvailable = parseInt(availabilityEl.dataset.available) || 0;
      const newAvailable = course.available;
      const isFull = newAvailable <= 0;

      // Update availability with animation if changed
      if (oldAvailable !== newAvailable) {
        availabilityEl.dataset.available = newAvailable;
        availabilityEl.className = `availability ${isFull ? 'full' : 'available'}`;
        availabilityEl.innerHTML = isFull ? 'Voll' : `${newAvailable} frei`;
        
        // Add pulse animation
        availabilityEl.style.animation = 'pulse 0.5s ease-in-out';
        setTimeout(() => {
          availabilityEl.style.animation = '';
        }, 500);
      }

      // Check current booking status from the card
      const wasBooked = card.classList.contains('booked');
      const wasWaiting = card.classList.contains('waiting');
      const wasInAnyStatus = wasBooked || wasWaiting;

      // Check new booking status
      const isBooked = course.userParticipation?.participationStatus === 1;
      const isWaiting = course.userParticipation?.participationStatus === 3;
      const isInAnyStatus = isBooked || isWaiting;
      
      // Update if status changed in any direction
      if (wasInAnyStatus !== isInAnyStatus || (isInAnyStatus && (wasBooked !== isBooked || wasWaiting !== isWaiting))) {
        const buttons = card.querySelectorAll('button');
        const primaryBtn = card.querySelector('.btn-primary');
        const titleEl = card.querySelector('h3');
        
        if (isBooked) {
          // Booked
          card.className = 'course-card booked';
          buttons.forEach(btn => btn.disabled = true);
          if (primaryBtn) primaryBtn.textContent = 'Angemeldet';
          // Update title badge
          if (titleEl) {
            const titleText = titleEl.textContent.split('<span')[0].trim();
            const courseName = course.description;
            titleEl.innerHTML = `${courseName} <span style="color: #91C736; font-weight: bold;">‚úì Angemeldet</span>`;
          }
        } else if (isWaiting) {
          // Waiting list
          card.className = 'course-card waiting';
          buttons.forEach(btn => btn.disabled = true);
          if (primaryBtn) primaryBtn.textContent = '‚è≥ Warteliste';
          // Update title badge
          if (titleEl) {
            const courseName = course.description;
            titleEl.innerHTML = `${courseName} <span style="color: #ffaa00; font-weight: bold;">Warteliste</span>`;
          }
        } else {
          // No longer booked/waiting (cancelled)
          card.className = `course-card ${isFull ? 'full' : ''}`;
          buttons.forEach(btn => btn.disabled = false);
          if (primaryBtn) {
            primaryBtn.textContent = isFull ? 'Warteliste' : 'Anmelden';
          }
          // Remove badge from title
          if (titleEl) {
            const courseName = course.description;
            titleEl.textContent = courseName;
          }
        }
        
        // Add flash animation for any status change
        card.style.animation = 'flash 0.5s ease-in-out';
        setTimeout(() => {
          card.style.animation = '';
        }, 500);
      }
    }

    function createCourseCard(course, days) {
      // This would create a new card element, but for now we can skip since courses don't usually appear mid-session
      return null;
    }

    // Schnelle Anmeldung
    async function quickRegister(bookingId) {
      addLog('info', `Starte Anmeldung f√ºr Booking ${bookingId}...`);
      
      try {
        const res = await fetch('/api/register', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ bookingId })
        });

        const data = await res.json();
        
        if (data.isWaitlist) {
          addLog('warning', `‚ö†Ô∏è Auf Warteliste gesetzt: ${data.message}`);
          if (data.fullResponse) {
            addLog('info', `Server: ${JSON.stringify(data.fullResponse)}`);
          }
          alert(`‚ö†Ô∏è Warteliste: ${data.message}`);
        } else if (data.success) {
          addLog('success', `‚úÖ Erfolgreich f√ºr Kurs ${bookingId} angemeldet!`);
          if (data.fullResponse) {
            addLog('info', `Server: ${JSON.stringify(data.fullResponse)}`);
          }
          alert('‚úÖ Erfolgreich angemeldet!');
          // Refresh course list after successful booking (silent mode)
          setTimeout(() => searchCourses(true), 1000);
        } else {
          addLog('error', `‚ùå ${data.message}`);
          if (data.fullResponse) {
            addLog('info', `Server: ${JSON.stringify(data.fullResponse)}`);
          }
          alert(`‚ùå ${data.message}`);
        }
      } catch (error) {
        addLog('error', error.message);
        alert(`Fehler: ${error.message}`);
      }
    }

    // Polling Modal
    function openPollingModal(bookingId) {
      document.getElementById('modalBookingId').value = bookingId;
      document.getElementById('pollingModal').classList.add('active');
    }

    function closePollingModal() {
      document.getElementById('pollingModal').classList.remove('active');
    }

    // Schedule Modal
    async function openScheduleModal(bookingId, courseStartTime, courseDescription) {
      const modal = document.getElementById('scheduleModal');
      const errorDiv = document.getElementById('scheduleModalError');
      errorDiv.classList.add('hidden');
      
      document.getElementById('scheduleBookingId').value = bookingId;
      document.getElementById('scheduleCourseStartTime').value = courseStartTime;
      document.getElementById('scheduleCourseDescription').value = courseDescription;
      document.getElementById('scheduleModalCourse').textContent = courseDescription;
      
      // Format course time
      const courseDate = new Date(courseStartTime);
      const days = ['Sonntag', 'Montag', 'Dienstag', 'Mittwoch', 'Donnerstag', 'Freitag', 'Samstag'];
      document.getElementById('scheduleCourseTime').textContent = 
        `${days[courseDate.getDay()]}, ${courseDate.toLocaleDateString('de-DE')} um ${courseDate.toLocaleTimeString('de-DE', { hour: '2-digit', minute: '2-digit' })} Uhr`;
      
      // Fetch booking info from server
      try {
        const res = await fetch(`/api/schedule/info?courseStartTime=${encodeURIComponent(courseStartTime)}`);
        const info = await res.json();
        
        const bookingAvailable = new Date(info.bookingAvailableAt);
        const pollingStart = new Date(info.pollingStartAt);
        const pollingStop = new Date(info.pollingStopAt);
        
        document.getElementById('scheduleBookingAvailable').textContent = 
          `${days[bookingAvailable.getDay()]}, ${bookingAvailable.toLocaleDateString('de-DE')} um ${bookingAvailable.toLocaleTimeString('de-DE', { hour: '2-digit', minute: '2-digit' })} Uhr`;
        document.getElementById('schedulePollingStart').textContent = 
          `~${pollingStart.toLocaleTimeString('de-DE', { hour: '2-digit', minute: '2-digit', second: '2-digit' })} Uhr (zuf√§llig)`;
        document.getElementById('schedulePollingStop').textContent = 
          `${pollingStop.toLocaleTimeString('de-DE', { hour: '2-digit', minute: '2-digit', second: '2-digit' })} Uhr`;
        
        const confirmBtn = document.getElementById('scheduleConfirmBtn');
        if (info.isInPast) {
          errorDiv.textContent = 'Der Buchungszeitraum ist bereits abgelaufen.';
          errorDiv.classList.remove('hidden');
          confirmBtn.disabled = true;
        } else if (info.isInWindow) {
          document.getElementById('schedulePollingStart').textContent = 'Sofort (Fenster aktiv)';
          confirmBtn.disabled = false;
        } else {
          confirmBtn.disabled = false;
        }
      } catch (error) {
        console.error('Error fetching schedule info:', error);
        errorDiv.textContent = 'Fehler beim Laden der Buchungsinformationen.';
        errorDiv.classList.remove('hidden');
      }
      
      modal.classList.add('active');
    }

    function closeScheduleModal() {
      document.getElementById('scheduleModal').classList.remove('active');
    }

    async function confirmSchedule() {
      const bookingId = document.getElementById('scheduleBookingId').value;
      const courseStartTime = document.getElementById('scheduleCourseStartTime').value;
      const courseDescription = document.getElementById('scheduleCourseDescription').value;
      const errorDiv = document.getElementById('scheduleModalError');
      
      try {
        const res = await fetch('/api/schedule', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ bookingId: parseInt(bookingId), courseStartTime, courseDescription })
        });
        
        const data = await res.json();
        
        if (res.ok && data.success) {
          closeScheduleModal();
          addLog('success', `üìÖ Buchung geplant f√ºr Booking ${bookingId}`);
          loadScheduledJobs();
          // Switch to register tab to show scheduled jobs
          document.querySelector('[data-tab="register"]').click();
        } else {
          errorDiv.textContent = data.error || 'Fehler beim Planen der Buchung';
          errorDiv.classList.remove('hidden');
        }
      } catch (error) {
        errorDiv.textContent = error.message;
        errorDiv.classList.remove('hidden');
      }
    }

    // Load and render scheduled jobs
    async function loadScheduledJobs() {
      try {
        const res = await fetch('/api/schedule');
        const data = await res.json();
        const jobs = data.jobs || [];
        
        // Update scheduled jobs map
        scheduledJobsMap.clear();
        jobs.forEach(job => {
          if (job.status === 'pending' || job.status === 'running') {
            scheduledJobsMap.set(job.bookingId, job);
          }
        });
        
        renderScheduledJobs(jobs);
        
        // Refresh course cards to show scheduled status
        const coursesList = document.getElementById('coursesList');
        if (coursesList && coursesList.children.length > 0) {
          searchCourses(true);
        }
      } catch (error) {
        console.error('Error loading scheduled jobs:', error);
      }
    }

    function renderScheduledJobs(jobs) {
      const container = document.getElementById('scheduledJobsList');
      const section = document.getElementById('scheduledJobsSection');
      
      const pendingJobs = jobs.filter(j => j.status === 'pending' || j.status === 'running');
      
      if (pendingJobs.length === 0) {
        container.innerHTML = '<p style="color: #666;">Keine geplanten Buchungen</p>';
        return;
      }
      
      const days = ['Sonntag', 'Montag', 'Dienstag', 'Mittwoch', 'Donnerstag', 'Freitag', 'Samstag'];
      
      let html = '';
      pendingJobs.forEach(job => {
        const bookingAvailable = new Date(job.bookingAvailableAt);
        const pollingStart = new Date(job.pollingStartAt);
        const courseStart = new Date(job.courseStartTime);
        const statusClass = job.status === 'running' ? 'running' : '';
        const statusText = job.status === 'running' ? 'üîÑ L√§uft...' : '‚è≥ Geplant';
        
        html += `
          <div class="scheduled-job-card ${statusClass}">
            <div style="display: flex; justify-content: space-between; align-items: flex-start;">
              <div>
                <strong>${job.courseDescription || `Booking ${job.bookingId}`}</strong>
                <span style="margin-left: 10px; color: ${job.status === 'running' ? '#ffaa00' : '#91C736'};">${statusText}</span>
              </div>
              ${job.status === 'pending' ? `<button class="btn btn-danger" onclick="cancelScheduledJob('${job.id}')">‚úï Abbrechen</button>` : ''}
            </div>
            <div class="schedule-info">
              <div class="schedule-info-item">
                <span class="schedule-info-label">Kurs</span>
                <span>${days[courseStart.getDay()]}, ${courseStart.toLocaleDateString('de-DE')} ${courseStart.toLocaleTimeString('de-DE', { hour: '2-digit', minute: '2-digit' })} Uhr</span>
              </div>
              <div class="schedule-info-item">
                <span class="schedule-info-label">Buchung verf√ºgbar</span>
                <span class="schedule-time-highlight">${days[bookingAvailable.getDay()]}, ${bookingAvailable.toLocaleTimeString('de-DE', { hour: '2-digit', minute: '2-digit' })} Uhr</span>
              </div>
              <div class="schedule-info-item">
                <span class="schedule-info-label">Polling startet</span>
                <span>~${pollingStart.toLocaleTimeString('de-DE', { hour: '2-digit', minute: '2-digit', second: '2-digit' })} Uhr</span>
              </div>
              <div class="schedule-info-item">
                <span class="schedule-info-label">Booking ID</span>
                <span>${job.bookingId}</span>
              </div>
            </div>
          </div>
        `;
      });
      
      container.innerHTML = html;
    }

    async function cancelScheduledJob(jobId) {
      if (!confirm('Geplante Buchung wirklich abbrechen?')) return;
      
      try {
        const res = await fetch(`/api/schedule/${encodeURIComponent(jobId)}`, {
          method: 'DELETE'
        });
        
        if (res.ok) {
          addLog('info', 'üìÖ Geplante Buchung abgebrochen');
          loadScheduledJobs();
        } else {
          const data = await res.json();
          addLog('error', data.error || 'Fehler beim Abbrechen');
        }
      } catch (error) {
        addLog('error', error.message);
      }
    }

    function startPollingFromModal() {
      const bookingId = document.getElementById('modalBookingId').value;
      const intervalSeconds = parseInt(document.getElementById('modalInterval').value) || 60;
      const maxAttempts = document.getElementById('modalMaxAttempts').value 
        ? parseInt(document.getElementById('modalMaxAttempts').value) 
        : null;

      if (ws && ws.readyState === WebSocket.OPEN) {
        ws.send(JSON.stringify({
          type: 'startPolling',
          bookingId,
          intervalSeconds: intervalSeconds,  // Bereits in Millisekunden
          maxAttempts
        }));
      }

      closePollingModal();
      
      // Wechsle zum Anmeldung-Tab
      document.querySelector('[data-tab="register"]').click();
    }

    // Register Mode Toggle
    document.getElementById('registerMode').addEventListener('change', (e) => {
      const isPolling = e.target.value === 'polling';
      document.getElementById('intervalGroup').style.display = isPolling ? 'block' : 'none';
      document.getElementById('maxAttemptsGroup').style.display = isPolling ? 'block' : 'none';
    });

    // Manueller Register Button
    document.getElementById('registerBtn').addEventListener('click', async () => {
      const bookingId = document.getElementById('bookingId').value;
      const mode = document.getElementById('registerMode').value;

      if (!bookingId) {
        alert('Bitte Booking ID eingeben');
        return;
      }

      if (mode === 'single') {
        await quickRegister(bookingId);
      } else {
        const intervalSeconds = parseInt(document.getElementById('intervalSeconds').value) || 1000;
        const maxAttempts = document.getElementById('maxAttempts').value 
          ? parseInt(document.getElementById('maxAttempts').value) 
          : null;

        if (ws && ws.readyState === WebSocket.OPEN) {
          ws.send(JSON.stringify({
            type: 'startPolling',
            bookingId,
            intervalSeconds: intervalSeconds,  // Bereits in Millisekunden
            maxAttempts
          }));
        }
      }
    });

    // Auth Import
    document.getElementById('importAuthBtn').addEventListener('click', async () => {
      const input = document.getElementById('authDataInput').value.trim();
      const resultDiv = document.getElementById('authResult');
      const autoFix = document.getElementById('autoFixJson').checked;

      if (!input) {
        resultDiv.className = 'alert alert-error';
        resultDiv.textContent = 'Bitte Auth-Daten einf√ºgen';
        resultDiv.classList.remove('hidden');
        return;
      }

      try {
        let authData;
        let cleanedInput = input;
        
        // Firefox "Copy Object" Format (Single Quotes)
        if (cleanedInput.startsWith("'") && cleanedInput.endsWith("'")) {
             // Entferne √§u√üere Single-Quotes
             cleanedInput = cleanedInput.slice(1, -1);
             
             // Firefox escapet Backslashes im String-Literal doppelt (z.B. userAgents)
             // Wir m√ºssen \\ zu \ machen, damit es valides JSON wird wie bei Chrome
             cleanedInput = cleanedInput.replace(/\\\\/g, '\\');
             
             // Eventuell escapte Single-Quotes \' zu ' machen
             cleanedInput = cleanedInput.replace(/\\'/g, "'");
        } 
        // Chrome "Copy String Contents" (manchmal mit " am Anfang/Ende wenn falsch kopiert)
        else if (cleanedInput.startsWith('"') && cleanedInput.endsWith('"')) {
             try {
                // Versuche es als JSON-String zu parsen (unquoting)
                cleanedInput = JSON.parse(cleanedInput);
             } catch (e) {
                // Fallback: Einfaches Entfernen der Quotes
                cleanedInput = cleanedInput.slice(1, -1);
             }
        }

        // Versuche zu parsen
        try {
          authData = JSON.parse(cleanedInput);
        } catch (parseError) {
           console.error('Parsing failed:', parseError);
           // Wenn das fehlschl√§gt, probieren wir den urspr√ºnglichen Input nochmal direkt
           // (vielleicht war es doch kein Firefox-Format oder wir haben zu viel entfernt)
           if (input !== cleanedInput) {
              try {
                authData = JSON.parse(input);
              } catch (e) {
                throw new Error(`JSON Parsing fehlgeschlagen: ${parseError.message}`);
              }
           } else {
              throw new Error(`JSON Parsing fehlgeschlagen: ${parseError.message}`);
           }
        }

        if (autoFix) {
            // Zus√§tzliche Sicherheits-Korrekturen f√ºr bekannte Probleme
            // Falls userAgents immer noch kaputt ist (z.B. [\"... statt ["...)
            const jsonStr = JSON.stringify(authData);
            
            // Fix f√ºr: userAgents":"[\"Android... (dies ist in Chrome korrekt, aber falls es doppelt escaped ist)
            // Hier sind wir vorsichtig. 
            // Der Server-Fix macht: replace(/\\\\/g, '\\') -> das haben wir oben schon f√ºr Firefox-Input gemacht.
            
            // Wir pr√ºfen, ob userAgents ein String ist, den wir parsen k√∂nnen
            if (authData.member && typeof authData.member.userAgents === 'string') {
                try {
                    JSON.parse(authData.member.userAgents);
                } catch (e) {
                    // Wenn userAgents nicht parsbar ist, ist es wahrscheinlich kaputt escaped
                    // Versuche zu reparieren: [\" -> ["
                    let ua = authData.member.userAgents;
                    if (ua.includes('[\\"')) {
                        authData.member.userAgents = ua.replace(/\\"/g, '"');
                    }
                }
            }
        }

        const res = await fetch('/api/auth/import', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            ...authData,
            _skipServerFix: !autoFix // Signal an Server
          })
        });

        const data = await res.json();

        if (data.success) {
          resultDiv.className = 'alert alert-success';
          resultDiv.innerHTML = `
            ‚úÖ Import erfolgreich!<br>
            Name: ${data.member.name}<br>
            Email: ${data.member.email}<br>
            ID: ${data.member.id}
          `;
          loadStatus();
        } else {
          resultDiv.className = 'alert alert-error';
          resultDiv.textContent = `‚ùå ${data.error}`;
        }
      } catch (error) {
        resultDiv.className = 'alert alert-error';
        resultDiv.textContent = `‚ùå Fehler: ${error.message}. Bitte pr√ºfe das Format der Daten.`;
        console.error(error);
      }

      resultDiv.classList.remove('hidden');
    });

    // Initial laden
    document.getElementById('intervalGroup').style.display = 'none';
    document.getElementById('maxAttemptsGroup').style.display = 'none';

    connectWebSocket();
    loadStatus();
    loadLocations();
    loadSports(); // L√§dt Sportarten und f√ºhrt initiale Suche aus
    loadScheduledJobs(); // Load scheduled jobs on page load
    
    // Kurse initial laden - Entfernt, da loadSports() das jetzt macht
    // document.getElementById('searchBtn').click();
  </script>
</body>
</html>
